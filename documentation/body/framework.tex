\chapter*{Development}
\addcontentsline{toc}{chapter}{Development}
\section*{Framework}
\addcontentsline{toc}{section}{Framework}
The following section will detail the components that make up the Taylor'd UI framework. Each of the following components are what makes up the framework, and aid in the development of a website. All the components of the framework have been built in separate partial files, denoted by an underscore. The underscore also tells codekit, the compiler been used to not compile the files into their own \gls{CSS} file. A separate file called taylord.scss was created, in this file the @include statement was used to pull all the separate partial files into one file and that file is then compiled to \gls{CSS}. 

\subsection*{Variables}
\addcontentsline{toc}{subsection}{Variables}
At the start of framework development, a file called \_foundation.scss was created, in this file all the variables for the framework are defined. In this file, the foundation colour variable is set and using the \gls{HSL} function called lighten, a range of colours are created to be used in the framework. Other colour variables were added and then used to set the background colour, alert colours, and link colours.

\newglossaryentry{SCSS}
{
  name={SCSS},
  description={Sassy Cascading Stylesheets},
  sort=SCSS
}

\newglossaryentry{HSL}
{
  name={HSL},
  description={Hue, Saturate, Lighten},
  sort=HSL
}

\begin{lstlisting}[language=CSS3]
	$foundation-color: #000;
	$foundation-color-2121: lighten($foundation-color, 
	13%);

	h1, h2, h3, h4, h5, h6 {
  	color: $foundation-color-2121;
\end{lstlisting}

\newpage
\subsection*{Font and Typography}
\addcontentsline{toc}{subsection}{Font and Typography}
In keeping with the framework being non opinionated, it was crucial to pick a font, and to have the typography nondescript so that the end user can change it to suit their needs. A range of fonts were looked at, the readability of the font in regards to large sections to single lines of text was looked at. 

Viewing the font on a range of devices ranging from mobile to desktop was looked at ensuring it was legible across these devices. The last aspect that was looked at was the range of the font, did it allow for non latin characters, accents and symbols\cite{WORD16}.

\newglossaryentry{px}
{
  name={px},
  description={pixel},
  sort=px
}
%

\newglossaryentry{em}
{
  name={em},
  description={element},
  sort=em
}

\newglossaryentry{rem}
{
  name={rem},
  description={Root element},
  sort=rem
}

The font that passed these tests, and was visually appealing was Open Sans. The next step was to determine the font sizing and how to calculate it. When decided on the best way to execute the font sizing, two methods were looked at, \gls{em} and \gls{rem}.\gls{px} was not looked at as early versions of Internet Explorer are not able to change the font size using browser functionality, a major usability issue. The \gls{em} technique alters the base font size on the body element by using a percentage \cite{GUN16}.

This adapts the font so that 1em is equal to 10px, instead of the default 16px. To change the font size to the equivalent of 14px, the \gls{em} needs to be 1.4em. The downside of using em to calculate the font sizing is that the font size compounds. This means that a list within a list isn't 14px but rather 20px. There is a work around where any child elements are declared to use 1em, but an entry level user would not know this. 

With the advent of \gls{CSS} 3, \gls{rem} was added, as previously mentioned, \gls{em} sizing was relative to the font size of the parent whereas \gls{rem} is relative to the root or html element. This means that a single font size can be defined for the html element, and all \gls{rem} units will be a percentage of that base unit. Safari 5, Chrome, Firefox 3.6+, and even Internet Explorer 9 have support for \gls{rem} units. Opera up to version 11.10, and early versions of Internet Explorer have yet to implement \gls{rem} units. In order to display font on these browsers, a fallback \gls{px} size is calculated using a mixin. 

\subsection*{Colour Scheme}
\addcontentsline{toc}{subsection}{Colour Scheme}
When creating the colour scheme, it was important to keep design opinions to a minimum, to use colours that would get the frameworks point across. It was also key to use colours that the end user would recognise that they were for instructional purposes, and for them to change in their web development projects. The colour needed to look good when modified as well, this means if the hue, tone and vibrancy of the colour is modified, the resulting colour needed to look well. 

Instead of researching colour theory and choosing the best colours, it was decided to use Google's Material Design \citet{Google17} colour palette, and choose from their wide range of colours. The palette  gave a variety of colours along with modifications of the colour such as different hues and saturations. The colours selected to use in the framework were kept to primary colours to keep it as non opinionated as possible.

\newpage
\subsection*{Tables}
\addcontentsline{toc}{subsection}{Tables}
Tables in HTML should only be used for rendering data that naturally belongs in a grid based system. This is data where the data characterised is similar across a number of objects. Tables should not be used for the layout of content in a website, divs should be used for this. The key to designing the tables was to demonstrate to the end user that the tables were for data, and not for layout.

Five table variations were created for the framework, ranging from default table to striped tables, and included is table modifiers. Table modifiers take the colours that are used to dictate success or warning, and add them to a row in the table. The tables were also designed to be responsive, to achieve this the padding of table is calculated by dividing the \$baseline height by a set value. 

\begin{lstlisting}[language=CSS3]
    .table.table-condensed > thead > tr > th,
    .table.table-condensed > tbody > tr > td {
      padding-top: $baseline-size / 2.4; // 5px
      padding-bottom: $baseline-size / 2.4;  // 5px
      padding-left: $baseline-size / 1.5;  // 8px
      padding-right: $baseline-size / 1.5; // 8px
    }
\end{lstlisting}


\subsection*{Buttons}
\addcontentsline{toc}{subsection}{Buttons}
Buttons are an integral part of a framework. The styling, and the functionality of the buttons are key in the end users goal of using a website. If a button does not look like a button or if the styling of a button is overdone, the user can get confused, and not know how to proceed. With this in mind, the development of the buttons continued throughout the development of the framework. Originally, the buttons had round corners but this was removed in trying to keep the design non opinionated. 

Five button types were designed at the start of the project. The default button, then large, and small buttons based off the default button, and lastly a pill shaped button. 

Based off the default button type, six styles were created. Each of these button styles has a visual waiting to it such as the warning button. This button can tell the user to proceed with caution, it can also be used as a delete button. To create these buttons a mixin was used that takes the colour stored in the variable for each of these classes. The mixin also adds in the active and hover states, and calculates the colours to be used. 

\begin{lstlisting}[language=CSS3]
.button-default {
  @include button-version($button-default-color,
   $button-default-background);
  color: $foundation-color-a6a6;
  text-decoration: none;
  border: $foundation-color-e8e8;
  border-style: solid;
  border-width: thin;
	}
}
\end{lstlisting}

\subsection*{Panels}
\addcontentsline{toc}{subsection}{Panels}
A panel is a component that allows you to outline a section of a web page. This enables you to view sections on your page as you add content to them, allowing you to place emphasis where you need it or removing all content from a section. 

\begin{lstlisting}[language=CSS3]
.panel-default {
  border-color: $default-border-bottom-color;

  .panel-title {
    @include panel-title($default-color-background, 
    $default-panel-text, $default-border-bottom-color);
  }
}
\end{lstlisting}

\newpage
\subsection*{Button Groups and Pagination}
\addcontentsline{toc}{subsection}{Button Groups and Pagination}
A button group is a series of buttons grouped together on a single line, this can be achieved by removing the margin attribute in CSS. Pagination is a series of numbers grouped together on a single line, this can be useful for when you have multiple pages in your website. As these two components can be used interchangeably, it was decided to include them together in the same partial.

To get these components working correctly, the $>$ symbol was used, this allowed for only the direct children of an element to be selected, and modified. It won't effect any other element that is not a direct child of that element. In the code snippet below only the a element of unordered list item belonging to the class pagination gets a solid 1px border.   

\begin{lstlisting}[language=CSS3]
.pagination > ul > li > a {
  border: 1px solid $foundation-color-e8e8;
}
\end{lstlisting}

\subsection*{Labels}
\addcontentsline{toc}{subsection}{Labels}
Button labels should be kept as simple as possible. Long labels take longer to read, and can also take up large sections of valuable real estate on mobile web pages. 

The button element illustrates a clickable button. The button element can be quite adaptable, elements such as images, text, headers, and even paragraphs can be in the button. The button element can also contain pseudo-elements such as ::before, and ::after. 

There is a clear difference between the label element, and a button created with an input element. An input element serves a data field, this is user data that you intend to dispatch to a server. There are several types of input related to a button.

\begin{lstlisting}[language=CSS3]
 <input type="submit">, <input type="image">, <input type="file">, 
 <$input type="reset">, <input type="button">. 
\end{lstlisting}


\newpage
\subsection*{Navigation}
\addcontentsline{toc}{subsection}{Navigation}
The navigation component of the framework is a simple responsive navigation menu  comprised of a non list style that becomes a drop down menu when the screen size is less than 640px.

On a larger browser window size, the navigation is designed to stay at the top of the browser window when the user is scrolling down on a web page, this is achieved by making the navigation fixed to the web page. As screen real estate is a commodity on smaller browser window sizes such as mobile, the navigation bar changes to absolute. The navigation bar now stays at the top of web page, giving more screen real estate to the user. 

\begin{lstlisting}[language=CSS3]
///over 640px
header {
	background: $foundation-white;
	width: 100%;
	height: 80px;
	position: fixed; 
	
///under 640px			
	nav {
		ul {
			display: none;
			position: absolute;
			padding: 10px;
\end{lstlisting}

\subsection*{States}
\addcontentsline{toc}{subsection}{States}
A state is an object that augments, and alters all other styles. For example, A message can be in a success or error state. States are commonly applied to the same element as a layout rule or applied to the same element as a base module class. In the frameworks, the states are used to indicate success in both alerts, and in a form. 

\begin{lstlisting}[language=CSS3]
.alert-success {
  color: darken($success-color, 15%);
  border-color: $success-color;
  background-color: lighten($success-color, 40%);
\end{lstlisting}

\newpage
\subsection*{Grid}
\addcontentsline{toc}{subsection}{Grid}

The grid is based on a 960 pixel grid or 60 rem in this case. The size is 60 rem as it is based on the default font size of 1 rem or 16 pixels. Using that as the base of the calculation, a font size of 960 pixels would be a rem value of 60. The reasons of why the grid is 960 pixels is that modern laptops, and or desktops no longer have a resolution below this. The 960 grid is evenly divisible in numerous ways as in in \ref{column}. 

This allows for a grid system that is adaptable to the a screen layout of any screen size. In using this type of grid system, a 12 column layout will also be used. The 12 column layout lends itself to the 960 grid as its also equally divisible, allowing for an odd number of columns all with even numbers as seen in figure \ref{fig:grid} whereas using a 16 grid column layout, the same result is not easily achieved. 

The framework has three breakpoints; desktop, tablet, and mobile. Based on the viewpoint, the columns expand or collapse in size. 

\begin{lstlisting}[language=CSS3]
$breakpoint-desktop: "screen and (min-width: 48rem) 
and (max-width: 60rem)";
$breakpoint-tablet: "screen and (min-width: 30rem) 
and (max-width: 47.9375rem)";
$breakpoint-mobile: "screen and (max-width: 29.9375rem)";
\end{lstlisting}

The media queries were developed using the rem mixin that was also used for font sizing, this allowed for the rem value and pixel value to be stored. For the columns, a media query for each target was included. Desktop, and tablet views have a rem, and pixel value. For mobile, percentages are used to better scale the content.

\newpage
\begin{lstlisting}[language=CSS3]
.col12 {
	@include rem(width, 960);

	@media #{$breakpoint-desktop} {
		@include rem(width, 960);
	}
	@media #{$breakpoint-tablet} {
		@include rem(width, 767);
	}
	@media #{$breakpoint-mobile} {
		 width: 100%;
	}
}
\end{lstlisting}

Even though the framework is designed for 12 grids, when the media queries were designed, a query was not made for each column of the grid. Not every column has a media query attached for it, instead the column around the missing column do the guess work for that column. 

The framework has been designed to be a starting point, for better control the user needs to add media queries for each column. The framework is intended as a teaching tool for the user, adding in the queries for them, would not be beneficial. 

\newpage
\subsection*{Alerts}
\addcontentsline{toc}{subsection}{Alerts}
Alert notifications can be used to alert the user that something is about to happen or has happened, this can be that their username or password is incorrect, their login was successful, something went wrong while trying to load content, et al.

Five different alert types were created, each with their own significance. All the alerts are built using the same alert class, and through the use of the modifiers are changed into each alert type. 

\begin{lstlisting}[language=CSS3]
.alert {
  color: inherit;
  border: 0.5px solid transparent;
  display: block;
  padding: 1.5rem;
  background-color: $success-color;
  @include border-radius($border-radius);
\end{lstlisting}

\subsection*{Mixins}
\addcontentsline{toc}{subsection}{Mixins}
\gls{mixins} are one of the most powerful features of \gls{SASS}. \gls{mixins} allow for efficient and clean code repetitions as well as an easy way to adjust your code with ease. \gls{mixins} are the \gls{SASS} equivalent of macros in other programming languages.

\gls{mixins} are used throughout the development of this framework in an effort to keep the code DRY. As seen in the example below, instead of having to write the border radius property for each browser, a mixin was written to do this for us. In the code, the mixin is called using the include statement @include border-radius. In the compiled CSS, the border radius property for each browser is added in automatically, 

\begin{lstlisting}[language=CSS3]
@mixin border-radius($radius) {
  border-radius: $radius;
  -webkit-border-radius: $radius;
  -moz-border-radius: $radius;
  -ms-border-radius: $radius;
}
\end{lstlisting}

\newpage
\section*{Development Issues}
\addcontentsline{toc}{section}{Development Issues}

\newglossaryentry{DRY}
{
  name={DRY},
  description={Don't Repeat Yourself},
  sort=DRY
}

Originally the framework was to be developed using \gls{SASS}, but as the development went on, and wanting to keep the code as \gls{DRY} as possible, \gls{mixins} were needed. Here within lies the issue, not enough \gls{SASS} was known at the start of the project to write \gls{SASS} \gls{mixins} or knowing how to convert \gls{SCSS} to \gls{SASS}. The development then continued until several partials were created but the use of \gls{mixins} were needed to continue the development using the correct methods. 

It was at this stage when development was stopped, enough \gls{SASS} was known to be able to convert the \gls{SASS} into \gls{SCSS}. After a day of conversion, ensuring that the \gls{SCSS} worked exactly like the \gls{SASS}, was development able to continue. 

\newglossaryentry{mixins}
{
  name={mixins},
  description={a mixin is a class that contains methods for use by other classes without having to be the parent class of those other classes.},
  sort=mixins
}

Another development issue was the buttons, the normal button was not clickable but the large, small, and pill button were. This was an issue that plagued the developer throughout the development. The code for buttons were rewritten a few times to see where the issue was, and no matter what was written, the button was not clickable, this issue then effected the default button, along with the classes that used the default button as a base such as the primary button. 

To figure out the cause of the issue, tools such as the Chrome Development tools were used. Using the inspect element feature, the button toggle state was used to force the element state as seen in \ref{fig:tools}. This allowed for each of the buttons states to be forced to run, while viewing the corresponding code to see where the error was. 

It seemed that the button issue was caused by the style to be overwritten by a different partial. To get the buttons to have their different states, the active, hover, and focus elements had to be hard coded into the button. In doing this, it didn't matter what other styles might override the values as the elements were hard coded.

A minor issue was trying to keep the code DRY both the SASS. and the compiled CSS was viewed to see if there was repeating code. When there was repeating code, \gls{mixins} were used where possible. Although there was sections of repeating code that converting to \gls{mixins} was not possible. 

Originally, the partials were going to be developed using web components \citet{Web17}, and Polymer \citet{Google17b}. The research had been done on these technologies, and how to use them. The development had started on the partials using these technologies but as the first partials were created, another student had viewing the work and asked "Is this not too complicated for your user?", and they were correct. The framework has been designed for the entry level user to understand, and use. Using the latest in web standards is likely to confuse them more. 

The below code snippet shows how a partial would work in using polymer. A template is made in a separate file and then called into the index file. The template is broken into different sections, the template section, and then the polymer section. Polymer is used to ensure that the template file is displayed in all browsers as the template tag is bot support by all browsers currently. 

\begin{lstlisting}[language=HTML]
\\example-app.html
dom-module id="example-app">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>
    <h2>Hello there[[prop1]]</h2>
  </template>

  <script>
    Polymer({

      is: 'example-app',

      properties: {
        prop1: {
          type: String,
          value: 'example-app',
        },
      },

    });
  </script>
</dom-module>

//index.html
<link rel="import" href="../iron-component-page/
iron-component-page.html">
<body>
   <iron-component-page src="example-app.html">
   </iron-component-page>
</body>
\end{lstlisting}

Instead the Ruby language is been used to develop the partials. Although the end user is likely to not know Ruby, the syntax is more user friendly. With using Ruby, the code is not overtaking the HTML as was the case with Polymer. The code snippets will always in the same places, this allows the end user to copy and paste the snippets in their websites without them having to know Ruby. Below is a code snippet of how a partial is rendering in a different file. 

\begin{lstlisting}[language=Ruby]
render template: "example/partial.html.erb"
\end{lstlisting}


themes were difficult to think off. 

One the the biggest obstacles in the development of this framework was deciding on what components were critical to the framework. Then what elements would the end user want. And finally, what elements does the developer think will be useful for the end user, elements that they need to understand without overcomplicating the framework, and or doing the work of the end user for them.

On of the biggest issues in the development of the framework was creating the grid layout, and media queries. The first major issue was the syntax. The breakpoints had been declared in a different partial, this lead to errors in the compiler. The compiler was looking for specific keywords after @media, which it wasn't able to interpret.

To solve this issue, the query had to be writing using different syntax. The variables for the breakpoints had to be treated as an ID. The compiler also would not accept brackets to frame the argument, curly braces had to be used instead. To reach this conclusion, a lot of trial and error was done. This involved making small changes to the @media argument, viewing  the error, viewing \gls{SASS} blogs to read what the error was in full, repeating this pattern until the code compiled with no errors. 
\begin{lstlisting}[language=CSS3]
//original 
@media ($breakpoint-mobile)

//new method
@media #{$breakpoint-mobile} 
\end{lstlisting}

\newpage
\section*{Project Plan}
\addcontentsline{toc}{section}{Project Plan}
\subsection*{Engineering Release One (January, and February):}
\addcontentsline{toc}{subsection}{Engineering Release One (January, and February)}
\begin{itemize}
	\item Iteration One: (9th of January - 23rd of January)\begin{itemize} 
	\item Met with Eamonn to discuss the best approach for the development in this semester
	\item Changed how partials would be created, and displayed from a static site generator to using web components, and polymer to display the websites across browsers that don't support the web components import element
	\end{itemize}
	\item Iteration Two: (23rd of January - 6th of February) \begin{itemize}
	\item Started development of the framework. Created the file structure, and a partial called base that will contain all the variables of the framework
	\item Decided on the colours and fonts that will be used in the framework
	\item Created the body partial that contains a generic layout for a html file
	\end{itemize}
	\item Iteration Three: (6th of February to 20th of February)\begin{itemize}
	\item Created the button partial
	\item Created the label partial to be used with the button partial
	\item Created general layout of semester two document, broke the document into two sections; user manual, and development
	\end{itemize}
	\subsection*{Engineering Release Two (March):}
	\addcontentsline{toc}{subsection}{Engineering Release Two (March)}
	\item Iteration Four: (20th of February - 6th of March)\begin{itemize} 
	\item Rewrote all the \gls{SASS} files to \gls{SCSS}
	\item Developed button mixins that would calculate all the button sizes
	\item Created Alerts partial
	\item Created States partial
	\item Created Panel partial
	\end{itemize}
	\item Iteration Five: (6th of March - 20th of March) \begin{itemize}
	\item Created Table partial
	\item Created Form partial
	\end{itemize}
	\subsection*{Engineering Release Three (April):}
	\addcontentsline{toc}{subsection}{Engineering Release Three (April)}
	\item Iteration Six: (20th of March - 3rd of April)\begin{itemize}
	\item Started work on the development section of the document, broke the development section into smaller sections for each partial. 
	\item Created Button Groups and Pagination partial
	\item Created Navigation partial
	\end{itemize}
		\item Iteration Seven: (3rd of April - 17th of April)\begin{itemize}
	\item Met with Eamonn, decided on final structure of report
	\item Added in Engineering Releases section
	\item Finalised all the sections of the report, reworded sections, ready for submission.
	\end{itemize}	
\end{itemize}

\newpage
\section*{Technologies}
\addcontentsline{toc}{section}{Technologies}

To compile the \gls{SCSS}, Codekit \citep{CODEKIT17} was used. Although \gls{SCSS} can be compiled from the command line or using a tool such as Grunt, using an application such as Codekit had extra features that would all have to be separate commands or even applications that made development easier. 

Codekit is an application that helps a developer build websites faster by automating tasks that a developer needs. CodeKit compiles languages such as SASS, Less, Stylus, and CoffeeScript. Codekit auto refreshes the browsers you are testing the website in, they offer built in hosting, that can be accessed by phones, tablets and other PC's. Codekit automatically minifies, and automatically checks the syntax ensuring it is correct, as well as optimising images. By automating these features, it can speed up the developers workflow. 

Originally, the development of the framework started with the \gls{SASS} language. \gls{SASS} is a \gls{CSS} preprocessor that has syntax advancements, the syntax uses indentation to format the code, and does not use semi-colons to indicate a new line. Stylesheets created in \gls{SASS} have to be compiled into regular \gls{CSS} stylesheets to be used. However, they do not extend the \gls{CSS} standard itself. 

However as development continued, mixins were found to be an issue when written in \gls{SASS}, \gls{SCSS} mixins could not be used with \gls{SASS} code. It was decided that the use of mixins were more important in the development of the \gls{CSS} than not. All the partials that were written in \gls{SASS} at this stage was converted into \gls{SCSS}. As this happened in the first few weeks of the development process, the process didn't take long. 

\gls{SCSS} is an extension of the \gls{CSS} syntax. This means that a correctly written \gls{CSS} file is also valid \gls{SCSS}. \gls{SCSS} uses semi-colons and braces to break up the code of an element. Variables in \gls{SCSS} are declared with \$, and the assignment sign is :. 

%
\newglossaryentry{SASS}
{
  name={SASS},
  description={Syntactically Awesome Stylesheets},
  sort=SASS
}
%

Rails is a development tool that gives developers a structure for all the code they write, a framework. The Rails framework helps developers to build websites and applications, because it abstracts, and simplifies common repetitive tasks. Rails was chosen as the language to develop the partials as the rails conventions allows for developers to move to different projects seamlessly as each project will follow the same structure, and coding practices. This will be of benefit to the entry level users. 

Ruby code is very readable, this will benefit the entry level user when they are reading the boilerplate files, gaining an understanding of how the boilerplate, and framework work. 

HTML is a markup language used in structuring, and presenting content on the Word Wide Web. HTML along with Ruby on Rails is been used to develop the boilerplates to that the end user can edit to suit their needs. 

LaTeX is a document preparation system for high-quality typesetting. The user uses markup tagging conventions to define the general structure of a document. LaTeX is been used in this project to develop the documentation that defines, and describes the project.
