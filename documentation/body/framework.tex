\chapter*{Development}
\addcontentsline{toc}{chapter}{5. Development}
\section*{Technologies}
\addcontentsline{toc}{section}{5.1 Technologies}

\subsection*{CodeKit}
\addcontentsline{toc}{subsection}{5.1.1CodeKit}

To compile the \gls{SCSS}subsection Codekit \citep{CODEKIT17} was used. Although \gls{SCSS} can be compiled from the command line or using a tool such as Grunt, using an application such as Codekit had extra features that would all have to be separate commands or even applications that made development easier. 

\subsection*{SCSS}
\addcontentsline{toc}{subsection}{5.1.2 SCSS}

\gls{SCSS} can be compiled by many different utilities such as Grunt. However, the decision was made to use Codekit \citep{CODEKIT17}. There are several reasons for this, it is a single application which compiles languages such as SASS, Less, Stylus, and CoffeeScript as well as offering tools such as built in local hosting that can be accessed from multiple devices, and automatic minifier all in a single package, and reduced the need to use many different applications to perform the same tasks performed by Codekit.
 
 The initial idea was to build the framework code using \gls{SASS}, however as development continued, \gls{mixins} were found to be an issue when written in \gls{SASS}, \gls{SCSS} \gls{mixins} could not be used with \gls{SASS} code. It was decided that the use of \gls{mixins} were more important in the development of the \gls{CSS} than not. The \gls{SASS} was converted into \gls{SCSS} to continue development. 
 
\gls{SCSS} is an extension of the \gls{CSS} syntax, which means that rules written in \gls{CSS} can also be considered to be valid \gls{SCSS}. \gls{SCSS} uses semi-colons and braces to break up the code of an element. Variables in \gls{SCSS} are declared with \$, and the assignment sign is :. 


%
\newglossaryentry{SASS}
{
  name={SASS},
  description={Syntactically Awesome Stylesheets},
  sort=SASS
}
%

\gls{mixins} are one of the most powerful features of \gls{SASS}/ \gls{SCSS}. They allow for efficient, and clean code repetitions as well as an easy way to adjust your code with ease. \gls{mixins} are the \gls{SCSS} equivalent of macros in other programming languages.

\subsection*{Nunjucks}
\addcontentsline{toc}{subsection}{5.1.3 Nunjucks}
Nunjucks is a rich, and powerful language used for templating. Nunjucks has features such as inheritance that other templating engines such as Handlebars do not. Gulp.js which is a task runner, is used alongside Nunjucks to remove the problem of repetition. 

A template engine is a tool that allows a user to break \gls{HTML} code into smaller pieces that can be reused across multiple \gls{HTML} files. Templating engines allow developers to write dynamic code, which can change based on what is inserted into a particular variable. This is extremely useful in situations such as localisation where different phrasing might be required. This can be achieved by using translation module such as i18n \citep{NPM16}. Another major benefit to this is the ability to separate content from stylisation \citep{CONT05}. Instead of using a application to develop the partials Gulp \citep{GULP17}, and Nunjucks \citep{NUN17} will be used.

\subsection*{HTML}
\addcontentsline{toc}{subsection}{5.1.4 HTML}
\gls{HTML} is a markup language used in structuring, and presenting content on the Word Wide Web. \gls{HTML} is the tool that the user will be using as the starting point of their development.

\subsection*{LaTeX}
\addcontentsline{toc}{subsection}{5.1.5 LaTeX}
The LaTeX Project is a document preparation system for high-quality typesetting. With LaTeX a documents content can be quickly and easily developed then styled through the use of markup tagging conventions which define the general structure of a project \citep{LAT17}.

\subsection*{Git}
\addcontentsline{toc}{subsection}{5.1.6 Git}
As the project will be large, with complicated parts, and to help in the development of the project, Git will be used for version control. Git works by creating snapshots of files. If there hasn't been any changes to specific file, Git will link it to a previous version, keeping the project fast, and lean \citep{GIT05}.

Having versions of the project will show what changes have been made over time, and if needed allow the project to be roll backed to a previous version. If a regression bug is introduced into the framework, it can be rolled back to a previous version easily using git \citep{ATL16}.

\newpage
\section*{Framework}
\addcontentsline{toc}{section}{5.2 Framework}
The Taylor'd UI framework is made up from the following components. Each of these components have been developed in separate partial files denoted by an underscore. The underscore is a keyword which is used to pass instructions to Codekit. A separate file called taylord.scss was created, in this file the \latinword{@includes} statement was used to pull all the separate partial files into one file and that file is then compiled to \gls{CSS}. 

\subsection*{Variables}
\addcontentsline{toc}{subsection}{5.2.1 Variables}
At the start of framework development, a file called \_foundation.scss was created, in this file all the variables for the framework are defined. In this file, the foundation colour variable is set and using the \gls{HSL} function called lighten. 

\gls{HSL} stands for Hue, Saturation, Lighten. Hue is a degree on the RGB colour wheel, this ranges from 0 to 360. 0 is red, 120 is green, and 240 is blue, Saturation is a percentage value; 0\% means a shade of grey and 100\% is the full colour. Lightness is also a percentage; 0\% is black, 100\% is white \citep{HSL16}.

A range of colours are created to be used in the framework. Other colour variables were added and then used to set the background colour, alert colours, and link colours.

\newglossaryentry{SCSS}
{
  name={SCSS},
  description={Sassy Cascading Stylesheets},
  sort=SCSS
}

\newglossaryentry{HSL}
{
  name={HSL},
  description={Hue, Saturate, Lighten},
  sort=HSL
}

\begin{lstlisting}[language=CSS3]
	$foundation-color: #000;
	$foundation-color-2121: lighten($foundation-color, 
	13%);

	h1, h2, h3, h4, h5, h6 {
  	color: $foundation-color-2121;
\end{lstlisting}

\newpage
\subsection*{Font and Typography}
\addcontentsline{toc}{subsection}{5.2.2 Font and Typography}
In keeping with the framework being non opinionated, it was crucial to pick a font, and to have the typography nondescript so that the end user can change it to suit their needs. A clear indicator of a suitable font, is that it that it is readable when used in individual lines and also in large blocks of text. 

Each candidate font was viewed on a range of devices including mobile, and desktop, thereby ensuring it was legible across multiple devices, and screen resolutions. Lastly the range of the font was looked at, did the font allow for non latin characters, accents, and symbols \citep{WORD16}.

\newglossaryentry{px}
{
  name={px},
  description={pixel},
  sort=px
}
%

\newglossaryentry{em}
{
  name={em},
  description={element},
  sort=em
}
%

\newglossaryentry{rem}
{
  name={rem},
  description={Root element},
  sort=rem
}
%

The font that passed these tests, and was visually appealing was Open Sans \citep{MATT17}. Open Sans was commissioned by Google and designed by Steve Matteson. Open Sans was designed to have a friendly, but neutral appearance and is optimised for legibility across different mediums such as print, web and mobile. 

The next step was to determine the font sizing and how to calculate it. Font sizing can be achieved using the three following methods; \gls{px}, \gls{em}, and \gls{rem}. \gls{px} was not looked at as early versions of Internet Explorer are not able to change the font size using browser functionality, a major usability issue. 

The \gls{em} technique alters the base font size on the body element by using a percentage \citep{GUN16}. This adapts the font so that 1em is equal to 10px, instead of the default 16px. To change the font size to the equivalent of 14px, the \gls{em} needs to be 1.4em. The downside of using \gls{em} to calculate the font sizing is that the font size compounds. This means that a list within a list isn't 14px but rather 20px. There is a work around where any child elements are declared to use 1em, but an entry level user would not know this. 

With the advent of \gls{CSS}3, \gls{rem} was added, as previously mentioned, \gls{em} sizing was relative to the font size of the parent whereas \gls{rem} is relative to the root or \gls{HTML} element. This means that a single font size can be defined for the \gls{HTML} element, and all \gls{rem} units will be a percentage of that base unit. Safari 5, Chrome, Firefox 3.6+, and even Internet Explorer 9 have support for \gls{rem} units. Opera up to version 11.10, and early versions of Internet Explorer have yet to implement \gls{rem} units. In order to display font on these browsers, a fallback \gls{px} size is calculated using \gls{mixins}. 

\subsection*{Colour Scheme}
\addcontentsline{toc}{subsection}{5.2.3 Colour Scheme}
When creating the colour scheme, it was important to keep design opinions to a minimum, to use colours that had more neutral tones, and that are not garish in appearance. It was also important to use colours that the end user would recognise that they were for instructional purposes, and for them to change in their own web development projects. The colour needed to look visually appealing when modified as well. This means if the hue, tone and vibrancy of the colour is modified, the resulting colour needed to be appealing as well. 

Instead of researching colour theory and choosing the best colours, it was decided to use Google's Material Design colour palette, and choose from their wide range of colours \citep{Google17}. The palette  gave a variety of colours along with modifications of the colour such as different hues and saturations.

For the neutral colours of the framework such as text and heading colours, a \gls{SASS} colour generator was used \citep{ARCH17}. The generator allowed for a base colour to be added, the output was lightened versions of the base colours. This was useful when creating the variable name, as the colour code could be entered at the end, enabling the end user to have a good idea of what the colour would look like. 

\subsection*{Tables}
\addcontentsline{toc}{subsection}{5.2.4 Tables}
Tables in \gls{HTML} should only be used for rendering data that naturally belongs in a grid based system. This is data where the data characterised is similar across a several objects. Tables should not be used for the layout of content in a website, divs should be used for this. The key to designing the tables was to demonstrate to the end user that the tables were for data, and not for layout.

Five table variations including table modifiers were created for the framework, ranging from default table to striped tables. Table modifiers take the colours that are used to dictate success or warning, and add them to a row in the table. The tables were designed to be responsive, this was achieved by taking the padding of table, and then dividing the \$baseline height by a set value as seen below. 

\begin{lstlisting}[language=CSS3]
    .table.table-condensed > thead > tr > th,
    .table.table-condensed > tbody > tr > td {
      padding-top: $baseline-size / 2.4; // 5px
      padding-bottom: $baseline-size / 2.4;  // 5px
      padding-left: $baseline-size / 1.5;  // 8px
      padding-right: $baseline-size / 1.5; // 8px
    }
\end{lstlisting}


\subsection*{Buttons}
\addcontentsline{toc}{subsection}{5.2.5 Buttons}
Buttons are an integral part of a framework. The styling, and the functionality of the buttons are key in the end users goal of using a website. If a button does not look like a button or if the styling of a button is overdone, the user can get confused, and not know how to proceed. The development of the buttons continued throughout the development of the framework. Originally, the buttons had round corners but this was removed in trying to keep the design non opinionated. 

Five button types were designed at the start of the project. The default button, then large, and small buttons based off the default button, and lastly a pill shaped button. 

Based off the default button type, six styles were created. Each of these button styles has a visual weighting to it such as the warning button. This button can tell the user to proceed with caution, it can also be used as a delete button. To create these buttons, \gls{mixins} was used that takes the colour stored in the variable for each of these classes. The \gls{mixins} also adds in the active and hover states, and calculates the colours to be used. 

\begin{lstlisting}[language=CSS3]
.button-default {
  @include button-version($button-default-color,
   $button-default-background);
  color: $foundation-color-a6a6;
  text-decoration: none;
  border: $foundation-color-e8e8;
  border-style: solid;
  border-width: thin;
	}
}
\end{lstlisting}

\subsection*{Panels}
\addcontentsline{toc}{subsection}{5.2.6 Panels}
A panel is a component that allows you to outline a section of a web page. This enables you to view sections on your page as you add content to them, allowing you to place emphasis where you need it or removing all content from a section. 

\begin{lstlisting}[language=CSS3]
.panel-default {
  border-color: $default-border-bottom-color;

  .panel-title {
    @include panel-title($default-color-background, 
    $default-panel-text, $default-border-bottom-color);
  }
}
\end{lstlisting}

\newpage
\subsection*{Button Groups and Pagination}
\addcontentsline{toc}{subsection}{5.2.7 Button Groups and Pagination}
A button group is a series of buttons grouped together on a single line, this can be achieved by removing the margin attribute in \gls{CSS}. Pagination is a series of numbers grouped together on a single line, this can be useful for when you have multiple pages in your website. As these two components can be used interchangeably, it was decided to include them together in the same partial.

To get these components working correctly, the $>$ symbol was used, this allowed for only the direct children of an element to be selected, and modified. It will not affect any other element that is not a direct child of that element. In the code snippet below only the a element of unordered list item belonging to the class pagination gets a solid 1px border.   

\begin{lstlisting}[language=CSS3]
.pagination > ul > li > a {
  border: 1px solid $foundation-color-e8e8;
}
\end{lstlisting}

\subsection*{Labels}
\addcontentsline{toc}{subsection}{5.2.8 Labels}
Button labels should be kept as simple as possible. Long labels take longer to read, and can also take up large sections of valuable real estate on mobile web pages. 

The button element illustrates a clickable button. The button element can be quite adaptable, elements such as images, text, headers, and even paragraphs can be in the button. The button element can also contain pseudo-elements such as \latinword{::before}, and \latinword{::after}. 

There is a clear difference between the label element, and a button created with an input element. An input element serves a data field, this is user data that you intend to dispatch to a server. There are several types of input related to a button.

\begin{lstlisting}[language=CSS3]
 <input type="submit">, <input type="image">, <input type="file">, 
 <$input type="reset">, <input type="button">. 
\end{lstlisting}


\newpage
\subsection*{Navigation}
\addcontentsline{toc}{subsection}{5.2.9 Navigation}
The navigation component of the framework is a simple responsive navigation menu  comprised of a non-list style that becomes a drop down menu when the screen size is less than 640px.

On a larger browser window size, the navigation is designed to stay at the top of the browser window when the user is scrolling down on a web page, this is achieved by making the navigation fixed to the web page. As screen real estate is a commodity on smaller browser window sizes such as mobile, the navigation bar changes to absolute. The navigation bar now stays at the top of web page, giving more screen real estate to the user. 

\begin{lstlisting}[language=CSS3]
///over 640px
header {
	background: $foundation-white;
	width: 100%;
	height: 80px;
	position: fixed; 
	
///under 640px			
	nav {
		ul {
			display: none;
			position: absolute;
			padding: 10px;
\end{lstlisting}

\subsection*{States}
\addcontentsline{toc}{subsection}{5.2.10 States}
A state is an object that augments, and alters all other styles. For example, A message can be in a success or error state. States are commonly applied to the same element as a layout rule or applied to the same element as a base module class. In the frameworks, the states are used to indicate success in both alerts, and in a form. 

\begin{lstlisting}[language=CSS3]
.alert-success {
  color: darken($success-color, 15%);
  border-color: $success-color;
  background-color: lighten($success-color, 40%);
\end{lstlisting}

\newpage
\subsection*{Grid}
\addcontentsline{toc}{subsection}{5.2.11 Grid}

The grid is based on a 960px grid or 60rem in this case. The size is 60rem as it is based on the default font size of 1rem or 16px. Using that as the base of the calculation, a font size of 960px would be a \gls{rem} value of 60. Modern desktops and laptops and mobile screens no longer tend to have resolutions below 960px, and for this reason the grid is set at this size as well as been evenly divisible in numerous ways as in in \ref{column}. 

The 960 grid is adaptable to any layout or screen size. With using the 960 grid, a 12 column layout will utilised. The 12 column layout lends itself to the 960 grid as its also equally divisible, allowing for an odd number of columns all with even numbers as seen in figure \ref{fig:grid} whereas using a 16 grid column layout, the same result is not easily achieved. 

The framework has three breakpoints; desktop, tablet, and mobile. Based on the viewpoint, the columns expand or collapse in size. 

\begin{lstlisting}[language=CSS3]
$breakpoint-desktop: "screen and (min-width: 48rem) 
and (max-width: 60rem)";
$breakpoint-tablet: "screen and (min-width: 30rem) 
and (max-width: 47.9375rem)";
$breakpoint-mobile: "screen and (max-width: 29.9375rem)";
\end{lstlisting}

The media queries were developed using the rem mixin that was also used for font sizing, this allowed for the rem value and pixel value to be stored. For the columns, a media query for each target was included. Desktop, and tablet views have a rem, and pixel value. For mobile, percentages are used to better scale the content.

\begin{lstlisting}[language=CSS3]
.col12 {
	@include rem(width, 960);

	@media #{$breakpoint-desktop} {
		@include rem(width, 960);
	}
	@media #{$breakpoint-tablet} {
		@include rem(width, 767);
	}
	@media #{$breakpoint-mobile} {
		 width: 100%;
	}
}
\end{lstlisting}

Using the class row fluid, the width has changed from a set number of 960px to width of 100\%. The percentage value allows for the columns to collapse in a predetermined pattern. The media query for mobile encompasses the fluid grid for it to scale down the columns. 

\begin{lstlisting}[language=CSS3]
.row-fluid [class^="col"] {

  @media #{$breakpoint-mobile} {
    margin-left: 0;
  }

  display: block;
  float: left;
  width: 100%;
  min-height: 30px;
  margin-left: 2.76%;
  *margin-left: 2.70%;
  @include box-sizing(border-box);
}
\end{lstlisting}
Even though the framework is designed for 12 grids, when the media queries were designed, a query was not made for each column of the grid. Not every column has a media query attached to it. Instead the column around the missing column does the guess work for that column. 

The framework has been designed to be a starting point, for better control the user needs to add media queries for each column. The framework is intended as a teaching tool for the user, adding in the queries for them, would not be beneficial. 

\newpage
\subsection*{Alerts}
\addcontentsline{toc}{subsection}{5.2.12 Alerts}
Alert notifications can be used to alert the user that something is about to happen or has happened, this can be that their username or password is incorrect, their login was successful, something went wrong while trying to load content, etc.

Five different alert types were created, each with their own significance. All the alerts are built using the same alert class, and through the use of the modifiers are changed into each alert type. 

\begin{lstlisting}[language=CSS3]
.alert {
  color: inherit;
  border: 0.5px solid transparent;
  display: block;
  padding: 1.5rem;
  background-color: $success-color;
  @include border-radius($border-radius);
\end{lstlisting}

\subsection*{Mixins}
\addcontentsline{toc}{subsection}{5.2.13 Mixins}
\gls{mixins} are used throughout the development of this framework in an effort to keep the code \gls{DRY} (Don't Repeat Yourself). What is meant by keeping your code DRY, is that you are removing elements that are repeated into one section and then just calling on that section. As seen in the example below, instead of having to write the border radius property for each browser, \gls{mixins} were written to do this automatically. In the code, the \gls{mixins} are called using the include statement @include border-radius. In the compiled \gls{CSS}, the border radius property for each browser is added in automatically, 

\begin{lstlisting}[language=CSS3]
@mixin border-radius($radius) {
  border-radius: $radius;
  -webkit-border-radius: $radius;
  -moz-border-radius: $radius;
  -ms-border-radius: $radius;
}
\end{lstlisting}


\newpage
\subsection*{Forms}
\addcontentsline{toc}{subsection}{5.2.14 Forms}
A \gls{HTML} form defines a form field that is used as a tool to gather user input. A \gls{HTML} form is made up of various input elements such as checkboxes, text areas, submit buttons, password fields, and mailto links. 

All types of input elements were considered, and one of each type has been added to the framework. By having one type of each input, it also allows the end user to build the element they require, using the form in the framework as their template. 

All the individual element stylings are covered under the one class of form-styling. This ensures that all the elements are following the parents style. 

To style the inputs, [] are used to select the type of input to style, as seen below: 

\begin{lstlisting}[language=CSS3]
input[type="radio"]
\end{lstlisting}

\newpage
\addcontentsline{toc}{section}{5.3 Templates, Partials and Themes}
\section*{Templates, Partials and Themes}

A total of three templates were made; a blog, portfolio, a product page. The templates were broken into partials so that there was no repetition of code, and for reusability. The templates themselves are bare, and have the look of a wireframe, as they are intended to be. The templates have been added to the framework as a learning tool, for the end user to manipulate with their own stylings, learning by doing. 

To build the partials, Gulp, and Nunjucks was used in tandem along with a plugin called gulp-nunjucks-render \citep*{PLUG17} . A gulp file was created that contained a script that is given the partial, and layout locations, and then compiles it into a \gls{HTML} file using the command gulp nunjuks.

\begin{lstlisting}[language=CSS3]
gulp.task('nunjucks', function() {
  // Gets .html and .nunjucks files in pages
  return gulp.src('template/blog/pages/**/*.+(html|nunjucks)')
  // Renders template with nunjucks
  .pipe(nunjucksRender({
      path: ['templates/blog/templates']
    }))
  // output files in app folder
  .pipe(gulp.dest('templates/blog'));
});

\end{lstlisting}

In an effort to remove any repetition, a loop was created in the layout file that repeated a certain partial for a set number of times, instead of having to recreate those elements multiple times. 

\begin{lstlisting}[language=CSS3]
{% for i in range(0, 3) -%}
  {% include "partials/portfolio.nunjucks" %}
{%- endfor %}
\end{lstlisting}

\newpage
The themes themselves were kept basic due to time constraints. Currently the themes only effect the visible elements of the three templates. 

When developing the themes, it was important to keep checking that the theme was not interfering with the framework. This was achieved by using Google's Inspect Element Tool. At stages through development, the link to the stylesheet was removed, to ensure that the layout from the framework was not disrupted. 

In the material theme, it was important to keep the stylings similar to those set out by Google. Extra features such as drop shadows were added. These were not in the original framework as they were thought to be opinionated. 


\begin{lstlisting}[language=CSS3]
.button {
  border-radius: 2px;
  font-size: 0.9em;
  background-color: #fff;
  color: #646464;
  transition: box-shadow 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  transition-delay: 0.2s;
  box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26)
}
\end{lstlisting}


\newpage
\section*{Development Issues}
\addcontentsline{toc}{section}{5.4 Development Issues}

\newglossaryentry{DRY}
{
  name={DRY},
  description={Don't Repeat Yourself},
  sort=DRY
}

Originally the framework was to be developed using \gls{SASS}, Several partials were developed, however to proceed further the use of \gls{mixins} would be required. This was not possible with the existing \gls{SASS}, and an effort to convert everything to \gls{SCSS} was undertaken.
 
\newglossaryentry{mixins}
{
  name={mixins},
  description={a mixin is a class that contains methods for use by other classes without having to be the parent class of those other classes.},
  sort=mixins
}

A bug within the button code surfaced which affected only certain buttons. This was an issue that plagued the developer throughout the development. The code for buttons were rewritten a few times to see where the issue was, and no matter what was written, the button was not clickable, this issue then effected the default button, along with the classes that used the default button as a base such as the primary button. 

To figure out the cause of the issue, tools such as the Chrome Development tools were used. Using the inspect element feature, the button toggle state was used to force the element state as seen in figure \ref{fig:tools}. This allowed for each of the buttons states to be forced to run, while viewing the corresponding code to see where the error was. 

It seemed that the button issue was caused by the style to be overwritten by a different partial. To get the buttons to have their different states, the active, hover, and focus elements had to be hard coded into the button. In doing this, it didn't matter what other styles might override the values as the elements were hard coded.

A minor issue was trying to keep the code \gls{DRY} both the \gls{SASS}. and the compiled \gls{CSS} was viewed to see if there was repeating code. When there was repeating code, \gls{mixins} were used where possible. Although there were sections of repeating code that converting to \gls{mixins} was not possible. 

Originally, the partials were going to be developed using Web Components \citep{Web17}, and Polymer \citep{Google17b}. The research had been done on these technologies, and how to use them. The development had started on the partials using these technologies but as the first partials were created, another student had viewing the work and asked \textit{"Is this not too complicated for your user?"}, and they were correct. The framework has been designed for the entry level user to understand, and use. Using the latest in web standards is likely to confuse them more.

The below code snippet shows how a partial would work in using polymer. A template is made in a separate file and then called into the index file. The template is broken into different sections, the template section, and then the polymer section. Polymer is used to ensure that the template file is displayed in all browsers as the template tag is bot support by all browsers currently. 

\begin{lstlisting}[language=HTML]
\\example-app.html
dom-module id="example-app">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>
    <h2>Hello there[[prop1]]</h2>
  </template>

  <script>
    Polymer({

      is: 'example-app',

      properties: {
        prop1: {
          type: String,
          value: 'example-app',
        },
      },

    });
  </script>
</dom-module>

//index.html
<link rel="import" href="../iron-component-page/
iron-component-page.html">
<body>
   <iron-component-page src="example-app.html">
   </iron-component-page>
</body>
\end{lstlisting}

One of the biggest obstacles in the development of this framework was deciding on what components were critical to the framework. Then what elements would the end user want. And finally, what elements does the developer think will be useful for the end user, elements that they need to understand without overcomplicating the framework, and or doing the work of the end user for them.

On of the biggest issues in the development of the framework was creating the grid layout, and media queries. The first major issue was the syntax. The breakpoints had been declared in a different partial, this lead to errors in the compiler. The compiler was looking for specific keywords after @media, which it could not interpret.

To solve this issue, the query had to be writing using different syntax. The variables for the breakpoints had to be treated as an ID. The compiler also would not accept brackets to frame the argument, curly braces had to be used instead. To reach this conclusion, a lot of trial and error was done. This involved making small changes to the @media argument, viewing  the error, viewing \gls{SASS} blogs to read what the error was in full, repeating this pattern until the code compiled with no errors. 
\begin{lstlisting}[language=CSS3]
//original 
@media ($breakpoint-mobile)

//new method
@media #{$breakpoint-mobile} 
\end{lstlisting}

Another issue in development was that the panels background were not taking the colour of the alert class specified. The classes were checked to ensure that nothing was out of place. The next step was to use Chrome Developer tools to see which backgrounds were been used. All the backgrounds were from the parent class. The code was checked again and the $<$ was included in the class, reaffirming that the alert colour was to take precedence. As of now, the panel background colours have not been fixed.

\begin{lstlisting}[language=CSS3]
.panel-info {
  border-color: $info-border-bottom-color;

  .panel-title {
    @include panel-title($default-color-background, $default-panel-text, 
    $default-border-bottom-color);
  }
}
\end{lstlisting}

One issue that appeared time, and time again in the framework was the the default font colour. Whenever the variable was called, the returning colour was blue, never black as the variable suggested. Changing the colour variable short code from \#000 to \#000000 did not solve the issue. As a work around the hex value was added to where the text needed to be black instead of using the colour variable. 

\newpage
\section*{Project Plan}
\addcontentsline{toc}{section}{5.5 Project Plan}
\subsection*{Engineering Release One (January, and February):}
\addcontentsline{toc}{subsection}{5.5.1 Engineering Release One (January, and February)}
\begin{itemize}
	\item Iteration One: (9th of January - 23rd of January)\begin{itemize} 
	\item Met with Eamonn to discuss the best approach for the development in this semester
	\item Changed how partials would be created, and displayed from a static site generator to using web components, and polymer to display the websites across browsers that don't support the web components import element
	\end{itemize}
	\item Iteration Two: (23rd of January - 6th of February) \begin{itemize}
	\item Started development of the framework. Created the file structure, and a partial called base that will contain all the variables of the framework
	\item Decided on the colours and fonts that will be used in the framework
	\item Created the body partial that contains a generic layout for a gls{HTML} file
	\end{itemize}
	\item Iteration Three: (6th of February to 20th of February)\begin{itemize}
	\item Created the button partial
	\item Created the label partial to be used with the button partial
	\item Created general layout of semester two document, broke the document into two sections; user manual, and development
	\end{itemize}
	\subsection*{Engineering Release Two (March):}
	\addcontentsline{toc}{subsection}{5.5.2 Engineering Release Two (March)}
	\item Iteration Four: (20th of February - 6th of March)\begin{itemize} 
	\item Rewrote all the \gls{SASS} files to \gls{SCSS}
	\item Developed button \gls{mixins} that would calculate all the button sizes
	\item Created Alerts partial
	\item Created States partial
	\item Created Panel partial
	\end{itemize}
	\item Iteration Five: (6th of March - 20th of March) \begin{itemize}
	\item Created Table partial
	\item Created Form partial
	\end{itemize}
	\subsection*{Engineering Release Three (April):}
	\addcontentsline{toc}{subsection}{5.5.3 Engineering Release Three (April)}
	\item Iteration Six: (20th of March - 3rd of April)\begin{itemize}
	\item Started work on the development section of the document, broke the development section into smaller sections for each partial. 
	\item Created Button Groups and Pagination partial
	\item Created Navigation partial
	\item Designed the poster that would accompany the project.
	\end{itemize}
		\item Iteration Seven: (3rd of April - 17th of April)\begin{itemize}
	\item Met with Eamonn, decided on final structure of report
	\item Added in Engineering Releases section
	\item Finalised all the sections of the report, reworded sections, ready for submission.
	\end{itemize}	
\end{itemize}